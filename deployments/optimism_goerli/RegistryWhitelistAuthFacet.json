{
  "address": "0xF66DD5fD74eFe262eE3D97AF394a2CF8b44a9892",
  "abi": [
    {
      "inputs": [],
      "name": "Ownable__NotOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorised",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "delegate",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "Approved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "nameWrapper",
          "type": "address"
        }
      ],
      "name": "SetNameWrapper",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "SetWhitelisted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newVersion",
          "type": "uint64"
        }
      ],
      "name": "VersionChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "node",
          "type": "bytes32"
        }
      ],
      "name": "isAuthorised",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setWhitelisted",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3e1e6d0b94acdfd1b66f26ad5e3ca109f0287ed7e698ad01a5384b6d6773aedd",
  "receipt": {
    "to": null,
    "from": "0x000000187c72ee4a4120a3E626425595a34F185B",
    "contractAddress": "0xF66DD5fD74eFe262eE3D97AF394a2CF8b44a9892",
    "transactionIndex": 1,
    "gasUsed": "346012",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x381ee0d6edef14fb20ac7be52853a3491e69ed5654e2914f6683011f84c35973",
    "transactionHash": "0x3e1e6d0b94acdfd1b66f26ad5e3ca109f0287ed7e698ad01a5384b6d6773aedd",
    "logs": [],
    "blockNumber": 7339039,
    "cumulativeGasUsed": "392925",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "78b35c2b1a9f0bafe48cd84ae3cc6b08",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorised\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nameWrapper\",\"type\":\"address\"}],\"name\":\"SetNameWrapper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"SetWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newVersion\",\"type\":\"uint64\"}],\"name\":\"VersionChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"isAuthorised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/diamond-resolver/facets/auth/RegistryWhitelistAuthFacet.sol\":\"RegistryWhitelistAuthFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2499},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6392f2cfe3a5ee802227fe7a2dfd47096d881aec89bddd214b35c5b46d3cd941\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xab28a56179c1db258c9bf5235b382698cb650debecb51b23d12be9e241374b68\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@solidstate/contracts/access/ownable/OwnableStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7385e2020de914f75cabdc83c6adf88ed21e9de14669a89b3832b80f4f8c7b73\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/auth/RegistryAuthFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../base/DiamondResolverBaseInternal.sol\\\";\\r\\nimport \\\"../base/IDiamondResolverAuth.sol\\\";\\r\\n\\r\\ncontract RegistryAuthFacet is DiamondResolverBaseInternal, IDiamondResolverAuth {\\r\\n    function isAuthorised(address sender, bytes32 node) public virtual view returns (bool) {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        address owner = l.ens.owner(node);\\r\\n        if (owner == address(l.nameWrapper)) {\\r\\n            owner = l.nameWrapper.ownerOf(uint256(node));\\r\\n        }\\r\\n\\r\\n        return\\r\\n            owner == sender ||\\r\\n            _isApprovedForAll(owner, sender) ||\\r\\n            _isApprovedFor(owner, node, sender);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x32503ba31a2758ebd7d76099fdbf5b80aea1e2a3bcf60939a5eaf34bd16d589a\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/auth/RegistryWhitelistAuthFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./RegistryAuthFacet.sol\\\";\\r\\n\\r\\nlibrary RegistryWhitelistAuthStorage {\\r\\n    struct Layout {\\r\\n        /**\\r\\n         * trustedETHController and trustedReverseRegistrar has right to control any name regardless of approval\\r\\n         * controller address => whitelisted\\r\\n         */\\r\\n        mapping(address => bool) whitelisted;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256('optidomains.contracts.storage.RegistryWhitelistAuthStorage');\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract RegistryWhitelistAuthFacet is RegistryAuthFacet {\\r\\n    event SetWhitelisted(address indexed operator, bool approved);\\r\\n\\r\\n    function isAuthorised(address sender, bytes32 node) public virtual override view returns (bool) {\\r\\n        return super.isAuthorised(sender, node) || RegistryWhitelistAuthStorage.layout().whitelisted[sender];\\r\\n    }\\r\\n\\r\\n    function setWhitelisted(address operator, bool approved) public baseOnlyOwner {\\r\\n        RegistryWhitelistAuthStorage.Layout storage l = RegistryWhitelistAuthStorage\\r\\n            .layout();\\r\\n        l.whitelisted[operator] = approved;\\r\\n        emit SetWhitelisted(operator, approved);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x6d5467bbeaa4f5e4d57abda2a33da42acd337598cf24b5a4a4b387994765c808\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/base/DiamondResolverBaseInternal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport {OwnableStorage} from \\\"@solidstate/contracts/access/ownable/OwnableStorage.sol\\\";\\r\\nimport \\\"./DiamondResolverBaseStorage.sol\\\";\\r\\nimport \\\"./DiamondResolverUtil.sol\\\";\\r\\n\\r\\nerror Ownable__NotOwner();\\r\\nerror ERC165Base__InvalidInterfaceId();\\r\\n\\r\\nabstract contract DiamondResolverBaseInternal is DiamondResolverUtil {\\r\\n    // This is done to prevent conflict\\r\\n    modifier baseOnlyOwner() {\\r\\n        if (msg.sender != OwnableStorage.layout().owner) revert Ownable__NotOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Logged when an operator is added or removed.\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    // Logged when a delegate is approved or an approval is revoked.\\r\\n    event Approved(\\r\\n        address owner,\\r\\n        bytes32 indexed node,\\r\\n        address indexed delegate,\\r\\n        bool indexed approved\\r\\n    );\\r\\n\\r\\n    event SetNameWrapper(address indexed nameWrapper);\\r\\n    function _setEns(ENS ens) internal {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        l.ens = ens;\\r\\n    }\\r\\n\\r\\n    function _setNameWrapper(INameWrapper nameWrapper) internal {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        l.nameWrapper = nameWrapper;\\r\\n        emit SetNameWrapper(address(nameWrapper));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function _setApprovalForAll(address operator, bool approved) internal {\\r\\n        require(\\r\\n            msg.sender != operator,\\r\\n            \\\"ERC1155: setting approval status for self\\\"\\r\\n        );\\r\\n\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        l.operatorApprovals[msg.sender][operator] = approved;\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve a delegate to be able to updated records on a node.\\r\\n     */\\r\\n    function _approve(bytes32 node, address delegate, bool approved) internal {\\r\\n        require(msg.sender != delegate, \\\"Setting delegate status for self\\\");\\r\\n\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        l.tokenApprovals[msg.sender][node][delegate] = approved;\\r\\n        emit Approved(msg.sender, node, delegate, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function _isApprovedForAll(\\r\\n        address account,\\r\\n        address operator\\r\\n    ) internal view returns (bool) {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        return l.operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check to see if the delegate has been approved by the owner for the node.\\r\\n     */\\r\\n    function _isApprovedFor(\\r\\n        address owner,\\r\\n        bytes32 node,\\r\\n        address delegate\\r\\n    ) internal view returns (bool) {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        return l.tokenApprovals[owner][node][delegate];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xf08a95875fbe72896aa021a67f8da38b8def551ee61c42802e3dcc2cc635b147\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/base/DiamondResolverBaseStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"../../../registry/ENS.sol\\\";\\r\\nimport {INameWrapper} from \\\"../../../wrapper/INameWrapper.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev derived from PublicResolver (MIT license)\\r\\n */\\r\\nlibrary DiamondResolverBaseStorage {\\r\\n    struct Layout {\\r\\n        ENS ens;\\r\\n        INameWrapper nameWrapper;\\r\\n\\r\\n        /**\\r\\n         * A mapping of operators. An address that is authorised for an address\\r\\n         * may make any changes to the name that the owner could, but may not update\\r\\n         * the set of authorisations.\\r\\n         * (owner, operator) => approved\\r\\n         */\\r\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\r\\n\\r\\n        /**\\r\\n         * A mapping of delegates. A delegate that is authorised by an owner\\r\\n         * for a name may make changes to the name's resolver, but may not update\\r\\n         * the set of token approvals.\\r\\n         * (owner, name, delegate) => approved\\r\\n         */\\r\\n        mapping(address => mapping(bytes32 => mapping(address => bool))) tokenApprovals;\\r\\n\\r\\n        mapping(bytes32 => uint64) recordVersions;\\r\\n\\r\\n        mapping(address => bool) supportsInterface;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256('optidomains.contracts.storage.DiamondResolverStorage');\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4b25a307611eb5535fda3f1eff24a492ae3a1aebc8d868259dfe10755b12e6f1\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/base/DiamondResolverUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"./DiamondResolverBaseStorage.sol\\\";\\r\\nimport \\\"./IVersionableResolver.sol\\\";\\r\\n\\r\\nabstract contract DiamondResolverUtil {\\r\\n    error Unauthorised();\\r\\n\\r\\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\\r\\n\\r\\n    function _recordVersions(bytes32 node) internal view returns (uint64) {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        return l.recordVersions[node];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Increments the record version associated with an ENS node.\\r\\n     * May only be called by the owner of that node in the ENS registry.\\r\\n     * @param node The node to update.\\r\\n     */\\r\\n    function _clearRecords(bytes32 node) internal virtual {\\r\\n        DiamondResolverBaseStorage.Layout storage l = DiamondResolverBaseStorage\\r\\n            .layout();\\r\\n        l.recordVersions[node]++;\\r\\n        emit VersionChanged(node, l.recordVersions[node]);\\r\\n    }\\r\\n\\r\\n    function _isAuthorised(bytes32 node) internal view returns (bool) {\\r\\n        (bool success, bytes memory result) = address(this).staticcall(\\r\\n            abi.encodeWithSelector(0x25f36704, msg.sender, node)\\r\\n        );\\r\\n        if (!success) return false;\\r\\n        return abi.decode(result, (bool));\\r\\n    }\\r\\n\\r\\n    modifier authorised(bytes32 node) {\\r\\n        if (!_isAuthorised(node)) revert Unauthorised();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x10a7fb98ee2250e8504a7a2a7300d8a8c86a3b2ba2808c611b81a7dfb1c7f1bf\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/base/IDiamondResolverAuth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\ninterface IDiamondResolverAuth {\\r\\n    function isAuthorised(address sender, bytes32 node) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x5a588cbb3e1667a9484ae5b4fe803675b1b909834904e4f9e53b60919c74d8dc\",\"license\":\"MIT\"},\"contracts/diamond-resolver/facets/base/IVersionableResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface IVersionableResolver {\\n    // event VersionChanged(bytes32 indexed node, uint64 newVersion);\\n\\n    function recordVersions(bytes32 node) external view returns (uint64);\\n    function clearRecords(bytes32 node) external;\\n}\\n\",\"keccak256\":\"0x63f6cd99d140ff213d2635b64708cbd3b49395bd6da66e68c3de37ba3c512b4b\",\"license\":\"MIT\"},\"contracts/ethregistrar/IBaseRegistrar.sol\":{\"content\":\"import \\\"../registry/ENS.sol\\\";\\nimport \\\"./IBaseRegistrar.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IBaseRegistrar is IERC721 {\\n    event ControllerAdded(address indexed controller);\\n    event ControllerRemoved(address indexed controller);\\n    event NameMigrated(\\n        uint256 indexed id,\\n        address indexed owner,\\n        uint256 expires\\n    );\\n    event NameRegistered(\\n        uint256 indexed id,\\n        address indexed owner,\\n        uint256 expires\\n    );\\n    event NameRenewed(uint256 indexed id, uint256 expires);\\n\\n    // Authorises a controller, who can register and renew domains.\\n    function addController(address controller) external;\\n\\n    // Revoke controller permission for an address.\\n    function removeController(address controller) external;\\n\\n    // Set the resolver for the TLD this registrar manages.\\n    function setResolver(address resolver) external;\\n\\n    // Returns the expiration timestamp of the specified label hash.\\n    function nameExpires(uint256 id) external view returns (uint256);\\n\\n    // Returns true iff the specified name is available for registration.\\n    function available(uint256 id) external view returns (bool);\\n\\n    /**\\n     * @dev Register a name.\\n     */\\n    function register(\\n        uint256 id,\\n        address owner,\\n        uint256 duration\\n    ) external returns (uint256);\\n\\n    function renew(uint256 id, uint256 duration) external returns (uint256);\\n\\n    /**\\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\n     */\\n    function reclaim(uint256 id, address owner) external;\\n}\\n\",\"keccak256\":\"0x9ac51351ff72d73083aed62b7cdad4c07e9d1eb68401d7fd8457bdd828f2c6fe\"},\"contracts/registry/ENS.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x7cb1158c7d268b63de1468e28e2711b28d686e2628ddb22da2149cd93ddeafda\"},\"contracts/wrapper/IMetadataService.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\ninterface IMetadataService {\\n    function uri(uint256) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xb3f1cf6df01ed7b15e5f2318f6823afbdb586ca38c2124c67955c645647ae9a2\",\"license\":\"MIT\"},\"contracts/wrapper/INameWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"../ethregistrar/IBaseRegistrar.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"./IMetadataService.sol\\\";\\nimport \\\"./INameWrapperUpgrade.sol\\\";\\n\\nuint32 constant CANNOT_UNWRAP = 1;\\nuint32 constant CANNOT_BURN_FUSES = 2;\\nuint32 constant CANNOT_TRANSFER = 4;\\nuint32 constant CANNOT_SET_RESOLVER = 8;\\nuint32 constant CANNOT_SET_TTL = 16;\\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\\nuint32 constant CANNOT_APPROVE = 64;\\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\\nuint32 constant IS_DOT_ETH = 1 << 17;\\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\\nuint32 constant CAN_DO_EVERYTHING = 0;\\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\\n// all fuses apart from IS_DOT_ETH\\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\\n\\ninterface INameWrapper is IERC1155 {\\n    event NameWrapped(\\n        bytes32 indexed node,\\n        bytes name,\\n        address owner,\\n        uint32 fuses,\\n        uint64 expiry\\n    );\\n\\n    event NameUnwrapped(bytes32 indexed node, address owner);\\n\\n    event FusesSet(bytes32 indexed node, uint32 fuses);\\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\\n\\n    function ens() external view returns (ENS);\\n\\n    function registrar() external view returns (IBaseRegistrar);\\n\\n    function metadataService() external view returns (IMetadataService);\\n\\n    function names(bytes32) external view returns (bytes memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function upgradeContract() external view returns (INameWrapperUpgrade);\\n\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n\\n    function wrap(\\n        bytes calldata name,\\n        address wrappedOwner,\\n        address resolver\\n    ) external;\\n\\n    function wrapETH2LD(\\n        string calldata label,\\n        address wrappedOwner,\\n        uint16 ownerControlledFuses,\\n        address resolver\\n    ) external returns (uint64 expires);\\n\\n    function registerAndWrapETH2LD(\\n        string calldata label,\\n        address wrappedOwner,\\n        uint256 duration,\\n        address resolver,\\n        uint16 ownerControlledFuses\\n    ) external returns (uint256 registrarExpiry);\\n\\n    function renew(\\n        uint256 labelHash,\\n        uint256 duration\\n    ) external returns (uint256 expires);\\n\\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\\n\\n    function unwrapETH2LD(\\n        bytes32 label,\\n        address newRegistrant,\\n        address newController\\n    ) external;\\n\\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\\n\\n    function setFuses(\\n        bytes32 node,\\n        uint16 ownerControlledFuses\\n    ) external returns (uint32 newFuses);\\n\\n    function setChildFuses(\\n        bytes32 parentNode,\\n        bytes32 labelhash,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        string calldata label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external returns (bytes32);\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        string calldata label,\\n        address newOwner,\\n        uint32 fuses,\\n        uint64 expiry\\n    ) external returns (bytes32);\\n\\n    function extendExpiry(\\n        bytes32 node,\\n        bytes32 labelhash,\\n        uint64 expiry\\n    ) external returns (uint64);\\n\\n    function canModifyName(\\n        bytes32 node,\\n        address addr\\n    ) external view returns (bool);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function ownerOf(uint256 id) external view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function getData(\\n        uint256 id\\n    ) external view returns (address, uint32, uint64);\\n\\n    function setMetadataService(IMetadataService _metadataService) external;\\n\\n    function uri(uint256 tokenId) external view returns (string memory);\\n\\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\\n\\n    function allFusesBurned(\\n        bytes32 node,\\n        uint32 fuseMask\\n    ) external view returns (bool);\\n\\n    function isWrapped(bytes32) external view returns (bool);\\n\\n    function isWrapped(bytes32, bytes32) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x70310eb67146d7290731c31841399640ac3b6a949eadc6598bc150123d185c57\",\"license\":\"MIT\"},\"contracts/wrapper/INameWrapperUpgrade.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ~0.8.17;\\n\\ninterface INameWrapperUpgrade {\\n    function wrapFromUpgrade(\\n        bytes calldata name,\\n        address wrappedOwner,\\n        uint32 fuses,\\n        uint64 expiry,\\n        address approved,\\n        bytes calldata extraData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x42e0cec6cd9d1a62d51d45b678f69d3e4ad5555e659b197e41257b308346bb8a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610550806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806325f367041461003b5780639281aa0b14610062575b600080fd5b61004e610049366004610493565b610077565b604051901515815260200160405180910390f35b6100756100703660046104bf565b6100d9565b005b600061008383836101fa565b806100d2575073ffffffffffffffffffffffffffffffffffffffff831660009081527f378200da64021ea95e57f25539bdb5dedb78afa36a3f553f54a02f28ced4961a602052604090205460ff165b9392505050565b7f8a22373512790c48b83a1fe2efdd2888d4a917bcdc24d0adf63e60f6716804605473ffffffffffffffffffffffffffffffffffffffff163314610149576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007f378200da64021ea95e57f25539bdb5dedb78afa36a3f553f54a02f28ced4961a73ffffffffffffffffffffffffffffffffffffffff84166000818152602083815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016871515908117909155915191825292935090917f26742d25b283cf51a0e3c4183d934871ed96d1bd33cf40706f87a94f29f686ac910160405180910390a2505050565b6000807f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dbe80546040517f02571be30000000000000000000000000000000000000000000000000000000081526004810186905291925060009173ffffffffffffffffffffffffffffffffffffffff909116906302571be390602401602060405180830381865afa158015610292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b691906104fd565b600183015490915073ffffffffffffffffffffffffffffffffffffffff908116908216036103765760018201546040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810186905273ffffffffffffffffffffffffffffffffffffffff90911690636352211e90602401602060405180830381865afa15801561034f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037391906104fd565b90505b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610401575073ffffffffffffffffffffffffffffffffffffffff80821660009081527f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dc0602090815260408083209389168352929052205460ff165b80610465575073ffffffffffffffffffffffffffffffffffffffff80821660009081527f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dc16020908152604080832088845282528083209389168352929052205460ff165b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461049057600080fd5b50565b600080604083850312156104a657600080fd5b82356104b18161046e565b946020939093013593505050565b600080604083850312156104d257600080fd5b82356104dd8161046e565b9150602083013580151581146104f257600080fd5b809150509250929050565b60006020828403121561050f57600080fd5b81516100d28161046e56fea26469706673582212204f351c7585bb937333e5207956e3e326ebb4f07543368613d8d6162b91e78be664736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806325f367041461003b5780639281aa0b14610062575b600080fd5b61004e610049366004610493565b610077565b604051901515815260200160405180910390f35b6100756100703660046104bf565b6100d9565b005b600061008383836101fa565b806100d2575073ffffffffffffffffffffffffffffffffffffffff831660009081527f378200da64021ea95e57f25539bdb5dedb78afa36a3f553f54a02f28ced4961a602052604090205460ff165b9392505050565b7f8a22373512790c48b83a1fe2efdd2888d4a917bcdc24d0adf63e60f6716804605473ffffffffffffffffffffffffffffffffffffffff163314610149576040517f2f7a8ee100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60007f378200da64021ea95e57f25539bdb5dedb78afa36a3f553f54a02f28ced4961a73ffffffffffffffffffffffffffffffffffffffff84166000818152602083815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016871515908117909155915191825292935090917f26742d25b283cf51a0e3c4183d934871ed96d1bd33cf40706f87a94f29f686ac910160405180910390a2505050565b6000807f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dbe80546040517f02571be30000000000000000000000000000000000000000000000000000000081526004810186905291925060009173ffffffffffffffffffffffffffffffffffffffff909116906302571be390602401602060405180830381865afa158015610292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b691906104fd565b600183015490915073ffffffffffffffffffffffffffffffffffffffff908116908216036103765760018201546040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810186905273ffffffffffffffffffffffffffffffffffffffff90911690636352211e90602401602060405180830381865afa15801561034f573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061037391906104fd565b90505b8473ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161480610401575073ffffffffffffffffffffffffffffffffffffffff80821660009081527f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dc0602090815260408083209389168352929052205460ff165b80610465575073ffffffffffffffffffffffffffffffffffffffff80821660009081527f8c151f2b073b889ff2e1725375750783c091724f29d93246786f4cca8f047dc16020908152604080832088845282528083209389168352929052205460ff165b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461049057600080fd5b50565b600080604083850312156104a657600080fd5b82356104b18161046e565b946020939093013593505050565b600080604083850312156104d257600080fd5b82356104dd8161046e565b9150602083013580151581146104f257600080fd5b809150509250929050565b60006020828403121561050f57600080fd5b81516100d28161046e56fea26469706673582212204f351c7585bb937333e5207956e3e326ebb4f07543368613d8d6162b91e78be664736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}